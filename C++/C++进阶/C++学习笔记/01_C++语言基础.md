# C++语言基础

---

## 一、结构体与类的区别

在 C++中，结构体（struct）和类（class）都用于定义自定义数据类型，允许将不同类型的数据组合在一起。尽管它们在许多方面相似，但它们之间还是存在一些关键的区别。

### 1. 默认访问权限

#### 结构体（struct）

默认情况下，结构体的成员是公共的（public）。

```cpp
struct Point {
    int x; // 默认 public
    int y; // 默认 public
};
```

#### 类（class）

默认情况下，类的成员是私有的（private）。

```cpp
class Point {
    int x; // 默认 private
    int y; // 默认 private
};
```

### 2. 继承方式

#### 结构体

默认继承方式是公有继承（public）。

```cpp
struct Base { };
struct Derived : Base { }; // 默认 public 继承
```

#### 类

默认继承方式是私有继承（private）。

```cpp
class Base { };
class Derived : Base { }; // 默认 private 继承
```

### 3. 语义和用途

#### 结构体

- 通常用于表示简单的数据结构，强调数据的组合
- 适合用于 C 风格的编程，或者当不需要复杂功能时

#### 类

- 通常用于实现更复杂的对象，强调数据和行为的封装
- 更适合进行面向对象编程，支持封装、继承和多态

### 4. 其他功能

#### 结构体

在 C++中，结构体也可以包含方法、构造函数和析构函数，但一般情况下，它们更少用于这些高级特性。

#### 类

类可以具备更复杂的功能，如访问控制、虚函数、多态等，提供更强大的数据抽象能力。

### 示例代码

```cpp
#include <iostream>

// 结构体定义
struct Point {
    int x; // 默认 public
    int y; // 默认 public
};

// 类定义
class Circle {
private:
    double radius; // 默认 private

public:
    Circle(double r) : radius(r) { } // 构造函数

    double getArea() const { // 成员函数
        return 3.14159 * radius * radius;
    }
};

int main() {
    Point p; // 使用结构体
    p.x = 10;
    p.y = 20;
    std::cout << "Point: (" << p.x << ", " << p.y << ")" << std::endl;

    Circle c(5.0); // 使用类
    std::cout << "Area of Circle: " << c.getArea() << std::endl;

    return 0;
}
```

### 总结

| 特性         | 结构体（struct） | 类（class）        |
| ------------ | ---------------- | ------------------ |
| 默认访问权限 | 公有（public）   | 私有（private）    |
| 默认继承方式 | 公有继承         | 私有继承           |
| 主要用途     | 组合简单数据     | 实现复杂对象和行为 |
| 语义         | 更倾向于数据结构 | 更倾向于对象封装   |

尽管结构体和类在 C++中的语法上有些不同，但它们可以互换使用，具体选择取决于设计需求和代码风格。

---

## 二、C++中的条件编译指令

条件编译指令在 C++中用于控制编译器对代码的编译，允许根据特定条件包含或排除代码块。

- **`#ifdef`**: 用于检查某个宏是否已定义，如果已定义，则编译该代码块
- **`#ifndef`**: 用于检查某个宏是否未定义。如果未定义，则编译该代码块
- **`#endif`**: 用于结束`#ifdef`、`#ifndef`或`#if`条件编译的代码块
- **`#if`**: 用于根据宏的值进行条件判断。如果条件为真，则编译该代码块
- **`#else`**: 用于提供在`#if`条件为假时的替代代码
- **`#elif`**: 用于在`#if`条件为假时检查另一个条件

---

## 三、C++中 const 关键字的作用及使用场景

`const`是 C++ 中用于声明常量性的关键字，确保对象或变量的值在初始化后不可被修改。

### 使用场景

- **修饰变量**：定义常量（如 `const int MAX = 100`）
- **修饰函数参数**：防止函数内部修改参数（如 `void func(const T& obj)`）
- **修饰成员函数**：声明函数不会修改对象状态（如 `int getValue() const`）
- **修饰返回值**：禁止修改返回结果（如 `const T& getRef()`）

### 知识拓展

#### 1. 顶层 const vs 底层 const

- **顶层 const**：指针本身是常量（指针常量，不可修改指向）

  ```cpp
  int x = 10;
  int* const ptr = &x;  // 顶层const
  ```

- **底层 const**：指针指向的对象是常量（常量指针，不可修改对象）

  ```cpp
  const int* ptr = &x;  // 底层const
  ```

  > **面试考点**：函数重载时，顶层 const 不构成重载，底层 const 构成重载

#### 2. 常量表达式（constexpr）

```cpp
constexpr int square(int x) {  // 编译期可计算的常量函数
    return x * x;
}
const int a = square(5);  // 编译期确定值
```

**区别**：`const` 强调运行时不可修改，`constexpr` 强调编译期可求值

#### 3. 常见面试问题

**Q1**: const 成员函数能否调用非 const 成员函数？

- **A**：不能。const 成员函数承诺不修改对象，而非 const 函数可能修改，因此编译器禁止调用。

**Q2**: 如何修改 const 对象的成员？

- **A**：
  - 通过强制类型转换（`const_cast`），但违反 const 语义，慎用
  - 将成员声明为 `mutable`（如 `mutable int cache;`）

**Q3**: 为什么建议传递参数时尽量使用 `const &`？

- **A**：
  - 避免值传递的拷贝开销（尤其对大型对象）
  - 通过 const 保证参数不被修改，增强代码安全性

## 四、static 关键字的作用

### 作用于变量

1. **局部静态变量**
   在函数内部声明静态变量时，该变量的生命周期将贯穿整个程序运行期，而不仅仅是函数执行期间，这意味着即使函数返回，静态变量的值也不会丢失，并且在下一次调用该函数时，静态变量将保持上一次的值。

   ```cpp
   void function() {
       static int count = 0;
       count++;
       //...
   }
   ```

2. **全局静态变量**
   在全局作用域或命名空间作用域中声明的静态变量，其作用域仅限于声明它的文件（即具有内部链接性），这有助于避免命名冲突。

3. **静态成员变量**
   在类中声明的静态成员变量与类相关联的，而不是与类的各个对象相关联，这意味着所有对象共享同一个静态成员变量。

   ```cpp
   class MyClass {
   public:
       static int staticVar;
   };
   ```

### 作用于函数

**静态成员函数**
在类中声明的静态成员函数可以在不创建对象的情况下被调用，它们只能访问静态成员变量。

```cpp
class MyClass {
public:
    static void staticFunction() {
        // ...
    }
};
```

### const 关键字补充

#### 作用于变量

**常量变量**
const 关键字用于声明常量变量，这意味着该变量的值在初始化后不能被修改。

#### 作用于指针

1. **常量指针**
   指针的指向可以修改，但是不能通过指针来修改所指向变量。

   ```cpp
   const int *ptr = &constVar;
   // *ptr = 20; //错误；不能修改指针所指向的值
   ptr = &anotherVar; // 正确；可以修改指针本身
   ```

2. **指针常量**
   指针的指向不能修改，但指针指向的变量可以修改。

   ```cpp
   int var = 10;
   int *const ptr = &var;
   *ptr = 20; //正确：可以修改指针所指向的值
   // ptr = &anotherVar; //错误： 不能修改指针本身
   ```

#### 作用于成员

**常成员函数**
在成员函数声明后面添加 const 关键字，表示该成员函数不会修改对象的任何成员变量（除了那些用 mutable 修饰的）。这有助于提高代码的可读性和安全性。

```cpp
class MyClass {
public:
    void constFunction() const {
        // ... 不能修改成员变量 ...
    }
};
```

#### 作用于返回值

**返回常量值**
如果函数返回的是一个常量值或常量引用，那么返回的结果不能被修改。

```cpp
const int getValue() {
    return 10;
}
```

#### 作用于参数

**常量参数**
将函数参数声明为常量，可以避免在函数内部意外修改参数的值，同时也有助于提高函数的通用性和可读性。

```cpp
void process(const int value) {
    // 不能修改 value 的值
}
```

## 五、什么是 C++中的 volatile 关键字？它在多线程编程中有什么作用？

在 C++中，volatile 关键字用于告诉编译器某个变量可能会在程序的其他部分被异步地改变，因此编译器不应该对该变量进行优化。volatile 主要用于处理那些可能在多线程或硬件上下文中改变的变量。

### 主要作用

1. **防止优化**
   当编译器优化代码时，它可能会假设变量的值在某个时刻不会变化，从而对代码进行重排或缓存。在多线程编程中，如果一个线程改变了某个变量的值，而另一个线程读取这个变量，如果这个变量没有被标记为 volatile，编译器可能会错误地缓存这个值，导致读取到旧值。

   ```cpp
   volatile int flag = 0;
   void threadFunction() {
       //其他线程可能会改变 flag 的值
       flag = 1; //改变 flag 的值
   }
   void mainThreadFunction() {
       while(flag == 0) { // do something...}
       // flag 的值被另一个线程改变后，退出循环
   }
   ```

2. **适用于硬件寄存器**
   在与硬件直接交互时，某些内存位置（如硬件寄存器）的值可能会被硬件异步地改变。在这种情况下，使用 volatile 可以确保编译器不会优化对这些内存位置的访问。

### 在多线程编程中的作用

- 确保对变量的读写操作不会被编译器优化掉，从而使得对该变量的更改对所有线程都是可见的
- 不保证原子性：虽然 volatile 能确保变量的可见性，但它并不能保证对变量操作的原子性。通常需要使用互斥量（mutex）等同步机制来保证线程安全。

## 六、什么是 C++中的 auto 关键字？它在现代 C++编程中有何用途？

### auto 关键字简介

在编程时，常常需要把表达式的值赋值给变量，这就要求在声明变量的时候清楚地知道表达式的类型，然而有时候要做到这点并非那么容易，因此 C++11 给 auto 赋予了新的含义。

auto 类型说明符是 C++11 新标准引入的，它可以让编译器替我们去分析表达式所属的类型，即通过表达式的值来推断变量的类型，因此，用 auto 定义的变量必须有初始值，它大大简化了代码书写，尤其是在变量类型复杂或冗长时。

### auto 关键字使用细则

1. 变量在定义时必须初始化。

2. 用 auto 声明指针类型时，用 auto 和 auto\* 没区别，但用 auto 声明引用类型时必须加&。

3. auto 一般会忽略掉顶层 const，同时底层 const 则会保留下来。

4. 编译器推断出来的 auto 类型有时候和初始值的类型并不完全一样，编译器会适当地改变结果类型使其更符合初始化规则，正如我们所熟知的，使用引用其实是使用引用的对象，特别是当引用被用作初始值时,真正参与初始化的其实是引用对象的值，此时编译器以引用对象的类型作为 auto 的类型。

5. 在同一行声明多个变量时，这些变量必须是相同的类型，否则编译器会报错，因为编译器实际只对第一个类型进行推导，然后推导出来的类型定义其他变量。

### auto 不能推导的场景

1. auto 不能对函数的参数类型进行推导，必须明确指定函数参数的类型。

2. auto 不能直接用来声明数组。

### auto 在现代 C++编程中的作用

1. 简化代码，提高代码的可读性。

2. 在 C++14 及更高版本中，可以使用 auto 作为 lambda 表达式的返回类型，简化了返回类型的声明。

3. 常用于范围 for 循环，简化了对容器的遍历。
