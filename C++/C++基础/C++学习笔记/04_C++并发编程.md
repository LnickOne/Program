# C++并发编程

---

## 一、如何在 C++中创建和管理线程？

### 简要回答
C++11 引入了 `<thread>` 头文件，提供了标准化的线程操作接口，使得多线程编程更加便捷和可移植。

### 详细回答

创建线程

使用 `std::thread` 创建一个线程，可以传递函数、函数指针、`lambda` 表达式等作为线程的执行内容。
线程的生命周期管理

- `join()`: 主线程调用 `join()` 来等待新线程的结束。`join()` 确保主线程等待子线程完成，避免主线程提前结束，导致子线程被销毁。
- `detach()`: 如果不需要等待线程结束，而是希望让线程独立运行，可以调用 `detach()`。被 `detach` 的线程会在后台继续执行，主线程结束后，`std::thread` 会自动清理线程资源。
线程的返回值

`std::thread` 本身不支持线程返回值。如果需要线程返回结果，可以使用 `std::future` 和 `std::promise` 来异步获取结果。

示例：使用 `std::async` 获取线程返回值

`std::async` 可以方便地创建一个线程并返回一个 `std::future`，通过 `future` 获取线程的结果。

```cpp
#include <iostream>
#include <future>

tint add(int a, int b) {
    return a + b;
}
int main() {
    // 使用 std::async 启动线程并返回 std::future
    std::future<int> result = std::async(std::launch::async, add, 5, 3);
    // 获取线程结果
    std::cout << "Result: " << result.get() << std::endl;
    return 0;
}
```

在这个例子中，`std::async` 创建了一个新的线程并执行 `add` 函数，返回一个 `std::future<int>` 对象。调用 `result.get()` 会阻塞主线程直到获取到线程的返回值。
在 C++中，我们通过 `std::thread` 类来创建线程。创建时需向其构造函数传递可调用对象——可以是普通函数、`Lambda` 表达式或类成员函数。对于成员函数，需要同时传递对象指针和函数参数。

线程启动后，必须通过 `join()`或 `detach()`进行生命周期管理：`join()`会确保主线程等待子线程完成，避免主线程提前结束，导致子线程被销毁；`detach()`则让线程在后台独立运行，主线程结束后，`std::thread` 会自动清理线程资源。

这里有个关键点：如果未调用 `join()`或 `detach()`，`std::thread` 析构时会强制终止程序，这是 C++防止线程泄漏的安全机制。
在现代 C++20 中，更推荐使用 `std::jthread`，它在析构时自动调用 `join()`，彻底避免手动管理的风险。

多线程环境下，共享数据必须通过同步机制保护——最常用的是 `std::mutex` 配合 `std::lock_guard` 实现 RAII 式加锁，或者使用 `std::atomic` 进行无锁编程。

对于简单异步任务，直接用 `std::async` 封装比手动管理线程更安全高效，它能自动处理结果返回和异常传递。

实际开发中，我会通过 `std::thread::hardware_concurrency()`获取硬件支持的并发数来优化线程数量，复杂场景则采用线程池模式避免频繁创建销毁。

总的来说，C++线程管理的核心在于严格遵循"创建-同步-回收"的生命周期，优先选用现代工具如 jthread 和 async，并始终确保共享数据的线程安全。

### 知识拓展
补充点（若面试官追问）：
- 为什么 detach()后无法控制线程？ 分离的线程由 C++运行时托管，无法再获取其状态或结果，也不保证生命周期。
- 何时该用 join() vs detach()？ join()用于需要等待结果的场景；detach()适用于后台监控、日志写入等无需交互的任务。
- 如何避免死锁？ 按固定顺序上锁，或用 std::lock(mtx1,mtx2)同时锁定多个互斥量，并配合 lock_guard 的 adopt_lock 标签。

## 二、请解释 C++11 中的 thread、mutex 和 lock_guard。

### 简要回答
在 C++11 中：
- std::thread：用于创建和管理线程。
- std::mutex：互斥量，用于保护共享数据，防止多个线程同时访问。
- std::lock_guard：是一个作用域锁，用于简化 mutex 的锁定和解锁操作。

### 详细回答

std::thread：

`std::thread` 类表示单个执行线程。它可以被用来包装函数或者可调用对象，从而在单独的线程中执行。

创建线程时，可以传递函数和参数，线程启动后会执行该函数。

线程可以通过 `join()`方法等待其完成，或者通过 `detach()`方法使其独立运行。

示例代码：

```cpp
#include <iostream>
#include <thread>

void func() {
    std::cout << "Hello from thread!" << std::endl;
}

int main() {
    std::thread t(func);
    t.join();
    return 0;
}
```

`std::mutex`：

`std::mutex` 是互斥量，提供基本的线程同步机制，用于保护共享数据。

当一个线程锁定了一个互斥量，其他尝试锁定同一个互斥量的线程将会阻塞，直到互斥量被解锁。

`std::mutex` 提供了 `lock()`、`unlock()`和 `try_lock()`方法来控制互斥量的状态。

示例代码：

```cpp
#include <iostream>
#include <thread>
#include <mutex>

std::mutex mtx; // 创建互斥量

void print_block(int n, char c) {
    mtx.lock(); // 锁定互斥量
    for (int i = 0; i < n; ++i) {
        std::cout << c;
    }
    std::cout << '\n';
    mtx.unlock(); // 解锁互斥量
}

int main() {
    std::thread t1(print_block, 50, '*');
    std::thread t2(print_block, 50, '$');
    t1.join();
    t2.join();
    return 0;
}
```

`std::lock_guard`：

`std::lock_guard` 是一个作用域锁，它在构造时自动锁定互斥量，并在析构时自动解锁互斥量。

它简化了互斥量的管理，避免了忘记解锁互斥量导致的死锁问题。

示例代码：

```cpp
#include <iostream>
#include <thread>
#include <mutex>

std::mutex mtx; // 创建互斥量

void print_block(int n, char c) {
    std::lock_guard<std::mutex> guard(mtx); // 自动锁定和解锁
    for (int i = 0; i < n; ++i) {
        std::cout << c;
    }
    std::cout << '\n';
}

int main() {
    std::thread t1(print_block, 50, '*');
    std::thread t2(print_block, 50, '$');
    t1.join();
    t2.join();
    return 0;
}
```

### 知识拓展

死锁：当两个或多个线程永久地等待对方持有的资源时，就会发生死锁。使用 std::lock_guard 而不是手动锁定和解锁互斥量可以减少死锁的风险。
RAII：std::lock_guard 遵循 RAII（Resource Acquisition Is Initialization）原则，即在对象构造时获取资源，在对象析构时释放资源，这是 C++管理资源的一种常见方式。
其他同步机制：除了 std::mutex 和 std::lock_guard，C++11 还提供了其他同步机制，如 std::unique_lock（提供更多灵活性），std::condition_variable（用于线程间的条件同步）等。
原子操作：在多线程编程中，有时可以使用原子操作来避免使用互斥量，从而提高性能。
锁策略：std::lock_guard 是独占锁，std::shared_mutex 提供了共享锁，允许多个线程读取共享数据，但只允许一个线程写入。
线程局部存储：thread_local 关键字可以声明线程局部存储的变量，这些变量在每个线程中都有独立的实例，互不干扰。

## 三、C++中 lock_guard 和 unique_lock 的区别？

### 简要回答
`std::lock_guard`：是一个作用域锁，构造时自动锁定互斥量，析构时自动解锁，不支持手动解锁和重新锁定。

std::unique_lock：提供了更灵活的互斥量锁定管理，可以手动解锁和重新锁定，支持条件变量，但性能略低于 lock_guard。

### 详细回答

`std::lock_guard`：

`std::lock_guard` 是一个 RAII 风格的互斥量锁管理类，它在构造时自动调用互斥量的 `lock()`方法，并在析构时自动调用 `unlock()`方法。

`std::lock_guard` 不支持手动解锁和重新锁定互斥量，因此它适用于简单的锁定需求，可以防止忘记解锁导致的死锁问题。

`std::lock_guard` 的构造函数可以接受一个 `std::adopt_lock` 参数，表示互斥量已经被当前线程锁定，无需再次锁定。

std::unique_lock：
`std::unique_lock` 也是一个 RAII 风格的互斥量锁管理类，但它提供了比 `std::lock_guard` 更灵活的锁定策略。

`std::unique_lock` 可以手动调用 `lock()`、`unlock()`和 `try_lock()`方法来控制互斥量的锁定状态。

`std::unique_lock` 支持移动语义，可以通过 `std::move` 将锁的所有权从一个 `unique_lock` 对象转移到另一个。

`std::unique_lock` 可以与 `std::condition_variable` 一起使用，支持等待特定条件，这是 `std::lock_guard` 无法做到的。

`std::unique_lock` 的构造函数接受多种参数，如 `std::defer_lock`（不立即锁定互斥量），`std::try_to_lock`（尝试锁定互斥量但不阻塞），`std::adopt_lock`（假定互斥量已被当前线程锁定）。

### 知识拓展

性能考量：由于 std::unique_lock 提供了更多的功能，它的性能通常略低于 std::lock_guard。如果不需要 unique_lock 的额外特性，应优先使用 lock_guard 以获得更好的性能。
灵活性：std::unique_lock 的灵活性使其适用于更复杂的同步场景，如需要条件变量的生产者-消费者问题。
移动语义：std::unique_lock 支持移动语义，这允许在函数之间传递锁的所有权，这在某些情况下非常有用。
锁策略：std::unique_lock 的构造函数参数允许开发者指定不同的锁策略，这为锁的管理提供了更高的灵活性。
条件变量：std::unique_lock 与 std::condition_variable 结合使用时，可以执行 wait()、wait_for()和 wait_until()操作，这些操作在等待条件满足时可以临时释放锁，从而避免不必要的资源占用。
异常安全：std::lock_guard 和 std::unique_lock 都提供了异常安全保证，即使在发生异常时，互斥量也会被正确解锁，防止死锁的发生。

## 四、什么场景下使用锁，什么场景下使用原子变量？

### 简要回答
使用锁：当需要保护多个相关操作或复杂的数据结构，以避免多个线程同时访问导致数据不一致时。

使用原子变量：当只需要执行简单的原子操作，如计数、标志设置或简单的数据交换时。

### 详细回答
- 使用锁：
  - 场景：锁（如互斥量、读写锁）适用于需要保护一段代码或多个相关变量，确保在同一时间只有一个线程可以执行这段代码或访问这些变量。
  - 优势：锁可以保护复杂的操作和数据结构，允许执行一系列的操作而不用担心中间状态被其他线程打断。
  - 劣势：锁可能导致死锁、饥饿或性能瓶颈，尤其是在高并发或锁粒度较粗的情况下。

- 使用原子变量：
  - 场景：原子变量适用于执行单一的操作，如增加计数器、设置布尔标志或进行简单的数据交换。
  - 优势：原子操作通常比锁更轻量级，不需要操作系统进行上下文切换，因此性能开销较小。
  - 劣势：原子变量仅限于简单的操作，无法用于保护复杂的数据结构或执行一系列的操作。

### 知识拓展

锁的实现：锁通常是通过操作系统提供的同步原语实现的，如信号量、互斥量等。在多核处理器上，锁的实现可能涉及到原子指令、自旋锁、队列锁等多种机制。
原子操作：原子操作是由硬件保证的，在执行过程中不会被其他线程中断。这些操作通常是通过特殊的 CPU 指令实现的，如 x86 架构的 LOCK 前缀指令。
内存模型：在 C++11 及以后的版本中，原子操作遵循特定的内存模型，这定义了原子操作的内存排序和可见性保证。这有助于开发者编写无锁编程或减少锁的使用。
性能考量：在高并发场景下，锁可能会导致线程频繁切换，从而降低性能。原子变量由于其轻量级特性，通常具有更好的性能表现。
死锁与饥饿：使用锁时需要小心避免死锁和饥饿问题。原子变量由于不涉及线程阻塞，因此不会导致死锁。
适用性：在选择锁还是原子变量时，需要考虑操作的复杂性、操作的频率、共享数据的性质以及并发级别。对于简单的操作，优先考虑原子变量；对于复杂的操作，可能需要使用锁。
无锁编程：在某些高性能应用中，开发者可能会倾向于使用原子变量实现无锁编程，这可以避免锁带来的性能问题，但同时也增加了编程的复杂度。

## 五、对 C++中 cv.wait(lock, condition)的理解？

### 简要回答
`cv.wait(lock, condition)`是 C++中条件变量的一种使用方式，它允许线程在满足特定条件之前阻塞，并在条件满足时唤醒。

### 详细回答

`cv.wait(lock, condition)`是 C++标准库中条件变量（`std::condition_variable`）的一个成员函数，用于在多线程编程中进行线程同步。以下是该函数的详细解释：
参数：
- lock：一个已经锁定的互斥量（`std::unique_lock` 或 `std::lock_guard`）。
- condition：一个布尔表达式，表示等待的条件。

行为：
- 当调用 `wait` 时，它首先会解锁传递给它的互斥量，这使得其他线程可以获取该互斥量并修改共享数据。
- 线程随后进入等待状态，直到其他线程调用 `notify_one()`或 `notify_all()`来唤醒它，或者直到虚假唤醒发生。
- 一旦线程被唤醒，它将重新锁定互斥量，然后检查条件是否满足。如果条件不满足，线程将继续等待；如果条件满足，线程将继续执行。

虚假唤醒：
虚假唤醒是指线程在没有调用 notify_one()或 notify_all()的情况下被唤醒。因此，条件变量应该总是与一个互斥量一起使用，并在循环中检查条件。

示例：

```cpp
std::mutex mtx;
std::condition_variable cv;
bool ready = false;

// 线程 1
{
    std::unique_lock<std::mutex> lock(mtx);
    cv.wait(lock, []{ return ready; });
    // 条件满足后执行的代码
}

// 线程 2
{
    std::lock_guard<std::mutex> lock(mtx);
    ready = true;
    cv.notify_one();
}
```

### 知识拓展

条件变量的原理：条件变量是基于生产者-消费者模型设计的，它允许线程在某些条件不满足时挂起，直到条件变为真。
性能考虑：条件变量通常比轮询（busy waiting）更高效，因为它允许线程在等待时释放 CPU，从而减少资源消耗。
避免死锁：在使用条件变量时，必须确保在调用 wait 之前互斥量已被锁定，以避免死锁。
std::condition_variable_any：与 std::condition_variable 类似，但 std::condition_variable_any 可以与任何类型的锁一起使用，而不仅仅是 std::unique_lock 或 std::lock_guard。
等待的持续时间：除了 wait()，条件变量还提供了 wait_for()和 wait_until()函数，它们允许线程等待特定的时间或直到某个时间点。

## 六、C++中如何使用 std::shared_mutex 实现读写锁？

### 简要回答
在 C++中，std::shared_mutex 用于实现读写锁，其中读操作通过 std::shared_lock 获取共享锁，写操作通过 std::unique_lock 获取独占锁。

### 详细回答
`std::shared_mutex` 是 C++17 引入的同步原语，用于控制对共享资源的并发访问。以下是使用 `std::shared_mutex` 实现读写锁的详细步骤：

定义共享互斥量：

```cpp
std::shared_mutex mutex;
```

读取数据：

当线程需要读取数据时，它应该使用 `std::shared_lock` 来锁定共享互斥量，允许多个线程同时读取。

```cpp
void read() {
    std::shared_lock<std::shared_mutex> lock(mutex);
    // 执行读取操作
}
```
写入数据：

当线程需要写入数据时，它应该使用 `std::unique_lock` 来锁定共享互斥量，确保在写入期间没有其他线程可以读取或写入。

```cpp
void write() {
    std::unique_lock<std::shared_mutex> lock(mutex);
    // 执行写入操作
}
```
完整示例：

```cpp
#include <shared_mutex>
#include <iostream>
#include <thread>

std::shared_mutex mutex;
int shared_data = 0;

void read_data() {
    std::shared_lock<std::shared_mutex> lock(mutex);
    std::cout << "Reading data: " << shared_data << std::endl;
}

void write_data(int value) {
    std::unique_lock<std::shared_mutex> lock(mutex);
    shared_data = value;
    std::cout << "Writing data: " << shared_data << std::endl;
}

int main() {
    std::thread t1(read_data);
    std::thread t2(write_data, 10);
    t1.join();
    t2.join();
    return 0;
}
```
### 知识拓展
读写锁的优势：读写锁相对于普通的互斥量可以显著提高并发性能，尤其是在读操作远多于写操作的场景下。
锁的粒度：使用 std::shared_mutex 时，需要注意锁的粒度。过粗的粒度可能导致性能下降，而过细的粒度可能导致编程复杂度增加。
死锁预防：在使用读写锁时，应该遵循一致的加锁顺序，以避免潜在的死锁问题。
条件变量：std::shared_mutex 可以与 std::condition_variable 或 std::condition_variable_any 结合使用，以等待特定条件。
锁的升级和降级：std::shared_mutex 本身不支持锁的升级（从共享锁到独占锁）或降级（从独占锁到共享锁），这通常需要额外的逻辑来实现。
