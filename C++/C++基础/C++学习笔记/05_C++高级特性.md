# C++高级特性

---

## 一、请解释 C++中的异常处理机制，并且给出一个例子

传统的错误处理机制：
终止程序：如 assert，缺陷：用户难以接受。如发生内存错误，除 0 错误时就会终止程序；
返回错误码：缺陷：需要程序员自己去查找对应的错误。如系统的很多库的接口函数都是通过把错误码放到 errno 中，表示错误，实际中 C 语言基本都是使用返回错误码的方式处理错误，部分情况下使用终止程序处理非常严重的错误.
C++中的异常处理机制
C++的异常情况无非两种，一种是语法错误，即程序中出现了错误的语句、函数结构和类，致使编译程序无法进行；另一种是运行时发生的错误，一般与算法有关.
关于语法错误， C++编译器的报错机制可以让我们轻松地解决这些错误; 第二种是运行时的错误，常见的有文件打开失败、数组下标溢出、系统内存不足等等，而一旦出现这些问题，引发算法失效、程序运行时无故停止等故障也是常有的，这就要求我们在设计算法时要全面，比如针对文件打开失败的情况，保护的方法有很多种，最简单的就是使用**“return”命令**，告诉上层调用者函数执行失败；另外一种处理策略就是利用 c++的异常机制，抛出异常.
C++的异常处理机制
C++异常处理机制是一个用来有效地处理运行错误的非常强大且灵活的工具，它提供了更多的弹性、安全性和稳固性，克服了传统方法所带来的问题，异常的抛出和处理主要使用了以下三个关键字： try、 throw 、 catch ；
throw：用于抛出一个异常
try：定义一个可能发生异常的代码块
catch：捕获并处理抛出的异常
异常的抛出和匹配原则
(1)异常对象的类型决定匹配：在抛出异常时，抛出的对象的类型决定了应该激活哪个 catch 块的处理代码，只有与抛出的异常对象类型匹配的 catch 块会被执行.
(2)最近匹配原则：如果在调用链中存在多个 catch 块与抛出的异常对象类型匹配，那么离抛出异常位置最近的 catch 块会被选中执行，这意味着程序会从当前位置开始，依次向上搜索调用链，直到找到最近匹配的 catch 块.
(3)异常对象的拷贝：抛出异常对象后，会生成该异常对象的拷贝，这是因为抛出的异常对象可能是一个临时对象，为了在异常处理期间保持异常对象的有效性，会创建一个拷贝对象，这个拷贝对象在 catch 块处理完异常后会被销毁.
(4)catch(...)的使用：catch(...)是一种特殊的 catch 块，可以捕获任意类型的异常，但是，它无法知道具体的异常类型，因此只能用于处理未知的异常错误，应该尽量避免在正常情况下使用 catch(...)，而是针对特定的异常类型提供明确的处理代码.
(5)异常的派生类匹配：实际中，可以抛出派生类对象，并在 catch 块中使用基类类型进行捕获，这种情况下，派生类对象会与基类类型匹配，因为派生类对象也是基类的一种形式，这种技术称为基类捕获，它在实际编程中非常实用，可以处理一组相关的异常类型.
需要注意的是，异常处理的匹配原则并不总是依赖于类型完全匹配，还涉及到派生类和基类之间的关系，这允许开发人员在 catch 块中使用更通用的异常类型来捕获一组相关的异常，并提供相应的处理代码.
在函数调用链中，异常栈展开的匹配原则是指异常在调用链中传播时如何查找匹配的 catch 块进行处理.
重新捕获是指在异常处理代码中重新抛出当前捕获的异常，使得该异常可以在调用栈的更高层次继续传播，重新捕获的目的是将异常传递给更高层的异常处理代码或者使得异常在程序的其他部分进行处理
在 C++中，通过使用 throw; 语句可以重新抛出当前捕获的异常，这个语句不带参数，它会重新抛出当前已捕获的异常对象，使得异常在调用栈中向上传播.
异常安全
在 C++中，建议在构造函数和析构函数中尽量避免抛出异常，以避免对象不完整或资源泄漏等问题.
构造函数中的异常
在构造函数中抛出异常可能导致对象不完整或没有完全初始化，当抛出异常时，已经执行的构造函数代码将被撤销，对象将被销毁，且析构函数不会被调用，这可能导致资源的泄漏或对象状态不一致，为了避免这种情况，应该在构造函数中尽可能避免抛出异常，或者使用初始化列表和异常安全的编程技术来处理异常.
析构函数中的异常
在析构函数中抛出异常同样会导致问题，当析构函数中抛出异常时，可能会导致其他代码无法正常处理资源的释放或清理操作，从而导致资源泄漏，为了避免这种情况，应该在析构函数中尽量避免抛出异常，或者使用异常安全的编程技术确保资源的正确释放
资源泄露问题
异常在 C++中确实可能导致资源泄漏的问题。例如，在使用 new 进行动态内存分配时，如果在分配后抛出异常而没有正确释放内存，就会导致内存泄漏。类似地，在使用锁进行资源保护时，如果在锁定和解锁之间抛出异常，可能导致死锁或资源未正确释放，为了解决这些问题，可以使用 RAII 技术，通过对象的构造函数获取资源，并在析构函数中自动释放资源，以确保资源在异常发生时也能正确释放.
C++标准库的异常体系
C++标准库提供了一个异常体系，其中定义了一些常见的异常类型，这些异常类型是继承自 std::exception 类的.
以下是一些 C++标准库中常见的异常类型：
std::exception：这是所有标准库异常类的基类，它提供了一个基本的接口，包括 what()方法用于获取异常的错误消息.
std::bad_alloc：当内存分配失败时，new 操作符会抛出该异常.
std::bad_cast：在类型转换失败时，比如使用 dynamic_cast 进行类的动态类型转换时，如果转换不成功，就会抛出该异常.
std::logic_error：这是一组逻辑错误的基类异常，派生自 std::exception，它的派生类包括：
std::invalid_argument：当函数参数无效或不合法时抛出。
std::domain_error：当参数在函数的定义域之外时抛出。
std::length_error：当容器长度超出其允许的最大限制时抛出。
std::runtime_error：这是一组运行时错误的基类异常，派生自 std::exception，它的派生类包括：
std::overflow_error：当进行数值溢出运算时抛出.
std::underflow_error：当进行数值下溢运算时抛出.
std::range_error：当数值超出有效范围时抛出.
std::out_of_range：当访问容器或数组中索引超出范围时抛出
C++异常处理机制的使用例子
处理零异常：
#include <iostream>
#include <stdexcept> // 用于 std::runtime_error

// 一个简单的除法函数
double divide(double numerator, double denominator)
{
if (denominator == 0)
{
// 抛出除零异常
throw std::runtime_error("Error: Division by zero");
}
return numerator / denominator;
}

int main()
{
double num1 = 10.0;
double num2 = 0.0; // 除数为零，触发异常

    try
    {
        // 尝试进行除法运算
        double result = divide(num1, num2);
        std::cout << "Result: " << result << std::endl;
    }
    catch (const std::runtime_error& e)
    {
        // 捕获并处理 std::runtime_error 异常
        std::cout << "Caught exception: " << e.what() << std::endl;
    }

    std::cout << "Program continues running after handling the exception." << std::endl;
    return 0;

}

函数的输出：
Caught exception: Error: Division by zero
Program continues running after handling the exception.

## 二、模板特化和偏特化有什么区别？

在 C++ 中，模板特化 和 模板偏特化 都是对模板的特定行为进行定制化的技术，但它们之间有显著的区别.
模板特化
模板特化是指为模板提供一个完全匹配特定类型或参数的专门实现，当通用模板无法满足某些特定需求，或者需要为特定类型优化性能时，可以使用模板特.
完全特化
完全特化指的是针对模板的所有参数提供一个具体的实现。换句话说，当所有模板参数都被指定为具体类型时，就可以进行完全特化
类模板的完全特化：
#include <iostream>
#include <string>

// 通用类模板
template <typename T>
class MyClass {
public:
void Show() const {
std::cout << "通用模板版本: " << typeid(T).name() << std::endl;
}
};

// 完全特化：针对 int 类型
template <>
class MyClass<int> {
public:
void Show() const {
std::cout << "特化模板版本 (int)" << std::endl;
}
};

int main() {
MyClass<double> obj1;
obj1.Show(); // 输出: 通用模板版本: d

    MyClass<int> obj2;
    obj2.Show(); // 输出: 特化模板版本 (int)

    return 0;

}

```#include <iostream>
#include <string>

// 通用类模板
template <typename T>
class MyClass {
public:
    void Show() const {
        std::cout << "通用模板版本: " << typeid(T).name() << std::endl;
    }
};

// 完全特化：针对 int 类型
template <>
class MyClass<int> {
public:
    void Show() const
   {
        std::cout << "特化模板版本 (int)" << std::endl;
    }
};

int main()
{
    MyClass<double> obj1;
    obj1.Show(); // 输出: 通用模板版本: d

    MyClass<int> obj2;
    obj2.Show(); // 输出: 特化模板版本 (int)

    return 0;
}
函数模板的完全特化：
函数模板也可以进行完全特化，但需要注意的是，函数模板只能进行完全特化，不能进行偏特化.
#include <iostream>
#include <string>

// 通用函数模板
template <typename T>
void Print(const T& data) {
    std::cout << "通用打印: " << data << std::endl;
}

// 完全特化：针对 std::string 类型
template <>
void Print<std::string>(const std::string& data) {
    std::cout << "字符串打印: " << data << std::endl;
}

int main() {
    Print(42);                  // 输出: 通用打印: 42
    Print(3.14);                // 输出: 通用打印: 3.14
    Print(std::string("Hello")); // 输出: 字符串打印: Hello

    return 0;
}
偏特化
偏特化允许开发者针对模板的一部分参数提供专门的实现，而不需要为所有参数都进行特化，这在处理具有多个模板参数的类模板时尤其有用.
类模板的偏特化：
假设有一个类模板 MyPair，它有两个类型参数 T1 和 T2，我们希望在 T2 是 int 类型时提供一个专门的实现.
#include <iostream>
#include <string>

// 通用类模板
template <typename T1, typename T2>
class MyPair {
public:
    void Show() const {
        std::cout << "通用模板版本: " << typeid(T1).name() << ", " << typeid(T2).name() << std::endl;
    }
};

// 偏特化：当 T2 是 int 类型
template <typename T1>
class MyPair<T1, int> {
public:
    void Show() const
   {
        std::cout << "偏特化模板版本: T2 是 int 类型" << std::endl;
    }
};

int main()
{
    MyPair<double, double> obj1;
    obj1.Show(); // 输出: 通用模板版本: d, i

    MyPair<std::string, int> obj2;
    obj2.Show(); // 输出: 偏特化模板版本: T2 是 int 类型

    return 0;
}
```

## 三、请描述 dynamic_cast 和 static_cast 的区别。

简要回答
dynamic_cast 主要用于在运行时检查并转换类型，适用于具有多态性质的指针或引用。static_cast 用于编译时类型转换，不进行运行时类型检查，适用于任何类型转换。
详细回答
dynamic_cast 和 static_cast 都是 C++中用于类型转换的操作符，但它们的使用场景和功能有所不同。 dynamic_cast：
dynamic_cast 主要用于将指针或引用安全地转换为目标类型的指针或引用。
它仅在对象类型具有多态性质时才有效，即对象必须是类的指针或引用，并且类必须至少有一个虚函数。
dynamic_cast 在运行时检查转换是否合法，如果转换不合法，对于指针转换会返回空指针（nullptr），对于引用转换会抛出 std::bad_cast 异常。
使用 dynamic_cast 通常会有一定的性能开销，因为它需要遍历对象的虚函数表来检查类型兼容性。 例子： cpp class Base { public: virtual void doSomething() {} }; class Derived : public Base { // ... }; Base* b = new Derived(); Derived* d = dynamic_cast<Derived*>(b); // 安全地向下转型 if (d) { // 转换成功 } else { // 转换失败 }
static_cast：
static_cast 用于执行任何类型的转换，只要这种转换在编译时是合法的，包括从派生类到基类的向上转型，从基类到派生类的向下转型，以及基本数据类型之间的转换。
static_cast 不进行运行时类型检查，因此它比 dynamic_cast 更高效，但不够安全。
如果转换不合法，static_cast 不会抛出异常，可能会导致未定义行为。 例子： cpp int a = 10; double b = static_cast(a); // 基本类型转换 Base* basePtr = new Derived(); Derived* derivedPtr = static_cast<Derived*>(basePtr); // 不安全的向下转型
知识拓展
RTTI（Run-Time Type Information）：dynamic_cast 操作符利用了 C++的 RTTI 机制，它通过对象的虚函数表和类型信息来确定两个类型之间是否存在继承关系。
类型转换的安全性：由于 dynamic_cast 在运行时进行类型检查，因此它比 static_cast 更安全，特别是在进行向下转型（从基类指针或引用转换到派生类指针或引用）时。
性能考量：static_cast 通常比 dynamic_cast 快，因为它不涉及运行时类型检查。然而，如果类型转换的安全性至关重要，那么性能上的损失通常是值得的。
其他类型转换操作符：除了 dynamic_cast 和 static_cast，C++还提供了 reinterpret_cast 和 const_cast。reinterpret_cast 用于低级转换，通常用于将指针转换为完全不同的类型。const_cast 用于去除或添加 const 属性。
使用建议：应该尽可能使用 C++提供的类型转换操作符，而不是传统的 C 风格类型转换（例如(type)value），因为 C++类型转换操作符更加明确，有助于代码的可读性和维护性。

## 四、请描述条件变量（std::condition_variable）的用途

## 五、请解释 C++中的智能指针（如 std::unique_ptr 和 std::shared_ptr）及其作用
