# C++面向对象编程

---

## 一、请解释一下什么是面向对象编程（OOP）以及它的主要特性是什么？

面向对象是一种编程范式，它通过将现实世界中的事物抽象为软件中的对象，使程序更易于理解、设计和维护。在 OOP 中，对象是类的实例，类是定义对象属性和行为的模板。 OOP 的主要特性包括：

### 封装
封装是将对象的属性和方法捆绑在一起，并隐藏对象的内部实现细节。这样可以保护对象的状态，只允许通过特定的方法访问和修改，从而提高数据安全和程序的可维护性。

### 继承
继承允许一个类从另一个类继承属性和方法，形成一种层次结构。通过继承，可以复用已有的代码，减少重复，实现代码的可扩展性。例如，一个子类可以继承父类的功能，并根据需要进行扩展或重写。

### 多态
多态性使同一操作在不同对象上可以表现出不同的行为。它通过方法重载和方法重写来实现，使程序更具有灵活性和可扩展性。

### 抽象
抽象是将复杂系统的复杂实现隐藏起来，只展示必要的部分。通过抽象，开发者可以忽略复杂细节，仅关注对象的接口，从而提高程序的维护性和可理解性。

## 二、面向对象的三大特性是什么？并简要说明每个特性的作用。

面向对象编程是 C++的核心特性之一。OOP 是一种编程范式，通过它，程序可以用对象的形式组织起数据和功能，并通过对象的交互来实现任务。面向对象的三大特性是封装，继承和多态。

### 封装
是指将现实事务封装成为抽象的类，然后在类中管理属性和行为，隐藏起属性和行为，仅对外暴露公开的接口与其他对象交互，避免外界干扰和非法访问。

### 继承
指子类可以继承父类的属性和行为的能力，从而重用父类的代码，并且可以在不修改父类代码的情况下，添加新的功能或是修改原有功能。继承提高了代码的可扩展性和层次性，实现了类的层级结构

### 多态
指同一操作对不同对象可以有不同的解释和功能。多态性允许以统一的操作处理不同类型的对象，从而提高了代码的可扩展性和可维护性。C++中多态通常是通过虚函数实现的，通过基类定义虚函数，派生类重新定义该函数，实现运行时的动态绑定。

## 三、类中的成员函数和成员变量有什么区别？

### 成员变量（Member Variables）
- **定义**：类中用于存储对象状态的数据。
- **特点**：
  - 每个对象有自己的一份成员变量副本。
  - 可以是不同的数据类型，如整型、浮点型、字符串等。
- **作用**：表示对象的属性或特征。

### 成员函数（Member Functions）
- **定义**：类中定义的函数，用于操作成员变量和实现对象的行为。
- **特点**：
  - 共享类的成员函数可以被所有对象调用。
  - 可以访问和修改成员变量的值。
- **作用**：实现对象的行为和功能，如初始化、操作、展示等。

## 四、C++构造函数有几种，分别什么作用？

C++构造函数主要有以下几种：
1. 默认构造函数：无参数，用于创建对象时初始化成员变量。
2. 参数化构造函数：带参数，用于根据传入的参数初始化对象。
3. 拷贝构造函数：接受同类型对象的引用，用于通过已有对象初始化新对象。
4. 移动构造函数（C++11 引入）：接受同类型对象的右值引用，用于“移动”资源而非复制。

### 详细回答

#### 默认构造函数
- **作用**：当对象被创建且没有提供任何参数时调用，用于初始化对象的成员变量。
- **底层**：编译器会自动生成一个默认构造函数，但如果用户定义了任何构造函数，编译器不会自动生成默认构造函数。

#### 参数化构造函数
- **作用**：根据传入的参数初始化对象的成员变量。
- **底层**：通过函数重载机制实现，编译器根据参数类型和数量选择合适的构造函数。

#### 拷贝构造函数
- **作用**：用于通过已有对象初始化新对象，通常用于对象复制。
- **底层**：编译器会自动生成一个默认的拷贝构造函数，执行浅拷贝。如果类中有动态内存分配，通常需要自定义拷贝构造函数以实现深拷贝。

#### 移动构造函数（C++11 引入）
- **作用**：用于“移动”资源而非复制，通常用于优化性能，特别是在涉及动态内存分配时。
- **底层**：通过右值引用（&&）实现，允许将资源从一个对象转移到另一个对象，避免不必要的复制操作。

### 知识拓展

1. **构造函数的重载**：C++允许构造函数重载，即同一个类可以有多个构造函数，只要它们的参数列表不同。
2. **构造函数的初始化列表**：用于在构造函数体执行前初始化成员变量，特别适用于常量成员和引用成员。
3. **委托构造函数（C++11 引入）**：允许一个构造函数调用同一个类中的另一个构造函数，减少代码重复。
4. **显式构造函数**：使用 explicit 关键字修饰的构造函数，防止隐式类型转换，避免意外的对象构造。

## 五、虚函数的作用是什么？为什么需要虚函数？

虚函数在 C++中是一种机制，允许派生类重写基类的方法并在运行时通过基类指针或引用调用派生类的重写方法。虚函数实现了运行时多态，是面向对象编程的重要特性之一，能够实现灵活和可扩展的代码。

### 虚函数的作用

1. **实现多态性**：虚函数使得可以在运行时根据实际对象类型来决定调用哪个函数。基类的指针或引用可以指向派生类对象，并调用派生类中重写的函数，而不是基类的实现。

2. **扩展性**：虚函数允许程序员在继承时重写基类的函数，从而实现新的行为。这样，程序能够以统一的接口处理不同的对象，提高了代码的可扩展性和灵活性。

3. **抽象接口**：通过在基类中声明虚函数，特别是纯虚函数，程序可以定义一个接口而无需具体实现，让派生类来实现具体逻辑。

### 为什么需要虚函数？

1. **实现运行时动态绑定**：在没有虚函数的情况下，C++使用静态绑定，在编译时确定函数调用。通过虚函数，可以实现动态绑定，即在运行时根据对象的实际类型调用适当的函数。

2. **多态行为的实现**：在使用基类指针或引用操作对象时，如果基类函数不是虚函数，那么会调用基类的实现，而不是派生类的重写方法。虚函数确保了派生类的实现被调用。

```cpp
class Base {
public:
    virtual void display() { // 虚函数
        std::cout << "Base class display function" << std::endl;
    }
    virtual ~Base() {} // 虚析构函数，确保正确销毁派生类对象
};

class Derived : public Base {
public:
    void display() override { // 重写基类的虚函数
        std::cout << "Derived class display function" << std::endl;
    }
};

int main() {
    Base* basePtr = new Derived();
    basePtr->display(); // 调用的是 Derived 的 display()，而不是 Base 的

    delete basePtr; // 确保调用 Derived 的析构函数
    return 0;
}
```

### 虚函数的好处

1. **多态性**：如上例所示，当通过基类指针调用 display()时，调用的是派生类的实现，而不是基类的实现。

2. **动态行为**：实现了不同对象的不同行为，可以在不修改原有代码的基础上增加新类，并重写虚函数。

3. **避免资源泄漏**：通过将析构函数声明为虚函数，可以在基类指针指向派生类对象时正确调用派生类的析构函数，防止资源泄漏。

### 虚函数与非虚函数的区别

- **虚函数**：在运行时决定调用哪一个版本的函数（动态绑定）。
- **非虚函数**：在编译时决定调用哪一个版本的函数（静态绑定）。

### 为什么需要虚函数的总结

1. 实现运行时多态，允许在程序运行期间根据对象的实际类型调用合适的函数。
2. 增强代码的扩展性和灵活性，方便实现接口和抽象类。
3. 保证正确的析构函数调用，尤其在使用多态时。
4. 虚函数是实现面向对象编程中多态的重要机制，使得代码可以适应未来的扩展和变化。

## 六、谈谈 C++中的拷贝构造函数和拷贝赋值运算符的作用及实现方式

### 拷贝构造函数

ClassA a(b)和 ClassA a = b 两种实例化方式涉及到从其他对象取值来构造新对象，这就是由拷贝构造函数来实现的：

```cpp
ClassA(const ClassA& c){
    // 应当深拷贝 c 的各成员变量。若用户不实现，则编译器自行生成一个浅拷贝的实现
}
```

函数以对象值的形式传参和返回时，底层就是在调用拷贝构造函数，因此很重要。

### 拷贝赋值运算符

与拷贝构造函数类似，只不过前者是初始化，后者是赋值。 其实现为：

```cpp
ClassA& operator=(const ClassA& c){
    // 实现拷贝赋值逻辑
}
```

注意应返回引用类型。
